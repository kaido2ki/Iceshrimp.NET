@using Iceshrimp.Frontend.Core.Miscellaneous
@using Iceshrimp.Frontend.Core.Services
@using Iceshrimp.Shared.Schemas
@using Ljbc1994.Blazor.IntersectionObserver
@using Ljbc1994.Blazor.IntersectionObserver.API
@using Ljbc1994.Blazor.IntersectionObserver.Components
@inject ApiService ApiService


<div @ref="Scroller" class="scroller">
    @if (_init)
    {
        @foreach (var note in Timeline)
        {
            <LazyNote Scroller="Scroller" Note="note"/>
        }

        <IntersectionObserve Options="new IntersectionObserverOptions() { Root = Scroller, RootMargin = _rootMagin }" OnChange="entry => OnEnd(entry)">
            <div @ref="context.Ref.Current" class="end">END!</div>
        </IntersectionObserve>
    }
    else
    {
        <div>Loading</div>
    }
</div>

@code {
    private List<NoteResponse> Timeline { get; set; } = [];
    private bool               _init           = false;
    private string?            MaxId     { get; set; }
    private string?            MinId     { get; set; }
    private bool               LockFetch { get; set; }
    public  ElementReference   Scroller  { get; set; }
    private string             _rootMagin = "100%";

    private async Task Initialize()
    {
        var pq  = new PaginationQuery() { Limit = 10 };
        var res = await ApiService.Timelines.GetHomeTimeline(pq);
        MaxId    = res[0].Id;
        MinId    = res.Last().Id;
        Timeline = res;
    }

    private async Task FetchOlder()
    {
        if (LockFetch) return;
        LockFetch = true;
        var pq  = new PaginationQuery() { Limit = 5, MaxId = MinId };
        var res = await ApiService.Timelines.GetHomeTimeline(pq);
        if (res.Count > 0)
        {
            MinId = res.Last().Id;
            Timeline.AddRange(res);
            StateHasChanged(); 
        }
        LockFetch = false;
    }

     private void OnEnd(IntersectionObserverEntry entry)
     {
         FetchOlder();
     }

     protected override async Task OnAfterRenderAsync(bool firstRender)
     {
         if (firstRender)
         {
             await Initialize();
             _init = true;
             StateHasChanged();
         }
     }

}
